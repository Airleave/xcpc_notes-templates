# 1.10 附录

## Code::Blocks 配置

- 点击 `Settings`，然后点击 `Environment...` ，将

> xterm -T $TITLE -x

- 改成

> gnome-terminal -t $TITLE -x

- 此后可通过右键粘贴，快捷键是 Ctrl+Shift+V。
- `while(cin...)` 或 `while(scanf(...)!=EOF)` 可通过 Ctrl+D 停止。

## __builtin

![12](D:\Folder.CSU\ACM\notes\12.png)

![13](D:\Folder.CSU\ACM\notes\13.png)

## Tricks

- 给定两棵 $n$ 个点的树 $T_1,T_2$，$q$ 次询问 $(x,y)$，求 $T_1$ 中以 $x$ 为根的子树与 $T_2$ 以 $y$ 为根的子树的并集。
  - 将每个点在两棵树上的 dfs 序看作是该点的两维坐标，每次询问相当于是矩形和。
  - 可以离线后扫描线，也可以在其中一棵树上线段树合并。
- **Sterling Formula**

$$
\lim \limits_{n \to \infty} \dfrac{n!}{\sqrt{2\pi n}\left(\frac{n}{e}\right)^n} = 1
$$

- 二次离线莫队例题
  
  - 给定序列 $a$，若干次询问 $[l,r]$，询问
  
  $$
  \sum \limits_{l \le i < j \le r}[\text{__builtin_popcount}(a_i \oplus a_j) = K]
  $$
  

```cpp
#include <bits/stdc++.h>

using std::ios;
using std::cin;
using std::cout;
using std::vector;

typedef long long ll;
const int N = 1e5 + 5;
const int C = 16384;
int T_data, n, m, cm, S, K;
int cnt[C + 5], a[N], cur[C + 5];
ll ans[N], sum[N], fans[N];

struct query
{
	int l, r, bl, id;
	
	query() {}
	query(int L, int R, int Bl, int Id):
		l(L), r(R), bl(Bl), id(Id) {}
		
	inline void scan(int _id)
	{
		cin >> l >> r;
		bl = (l - 1) / S + 1;
		id = _id;
	}
	
	inline bool operator < (const query &a) const 
	{
		return bl < a.bl || bl == a.bl && r < a.r;
	}
}q[N];

struct modify
{
	int l, r, t, i;
	
	modify() {}
	modify(int L, int R, int T, int I):
		l(L), r(R), t(T), i(I) {}
};
vector<modify> v[N]; 

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cout.tie(nullptr);
	
	cin >> n >> m >> K;
	if (K > 14)
	{
		for (int i = 1; i <= m; ++i)
			cout << 0 << '\n';
		return 0; 
	} 
	S = n / sqrt(m) + 1;
	for (int i = 1; i <= n; ++i)
		cin >> a[i];
	for (int i = 1; i <= m; ++i)
		q[i].scan(i);
	std::sort(q + 1, q + m + 1);
	for (int i = 0; i < C; ++i)
		if (__builtin_popcount(i) == K)
			cur[++cm] = i;
	for (int i = 1; i <= n; ++i)
	{
		sum[i] = sum[i - 1] + cnt[a[i]];
		for (int j = 1; j <= cm; ++j)
			++cnt[a[i] ^ cur[j]];
	}
	for (int i = 0; i < C; ++i)
		cnt[i] = 0;
	int tl = 1, tr = 0;
	for (int i = 1; i <= m; ++i)
	{
		int l = q[i].l, r = q[i].r;
		if (tr < r)
		{
			v[tl - 1].push_back(modify(tr + 1, r, -1, i));
			ans[i] += sum[r] - sum[tr];
			tr = r;
		}	
		if (tr > r)
		{
			v[tl - 1].push_back(modify(r + 1, tr, 1, i));
			ans[i] -= sum[tr] - sum[r];
			tr = r;
		}
		if (tl < l)
		{
			v[tr].push_back(modify(tl, l - 1, -1, i));
			ans[i] += sum[l - 1] - sum[tl - 1];
			tl = l;
		}
		if (tl > l)
		{
			v[tr].push_back(modify(l, tl - 1, 1, i));
			ans[i] -= sum[tl - 1] - sum[l - 1];
			tl = l;
		}
	}
	for (int i = 1; i <= n; ++i)
	{
		for (int j = 1; j <= cm; ++j)
			++cnt[a[i] ^ cur[j]];
		for (modify t : v[i])
			for (int j = t.l; j <= t.r; ++j)
				ans[t.i] += t.t * (cnt[a[j]] - (!K && j <= i));
	} 
	for (int i = 1; i <= m; ++i)
		ans[i] += ans[i - 1];
	for (int i = 1; i <= m; ++i)	
		fans[q[i].id] = ans[i];
	for (int i = 1; i <= m; ++i)
		cout << fans[i] << '\n';
	return 0;
}
```

- 弧度用二维互质向量表示，重载小于表示 atan2 值的小于（通过分区讨论实现）。

```cpp
struct point
{
	ll x, y;
	
	point() {}
	point(ll X, ll Y):
		x(X), y(Y) {}
	ll operator * (const point &r) const {return x * r.y - y * r.x;}
	
	inline point norm() const 
	{
		ll e = std::__gcd(x, y);
		if (e < 0) e = -e;
		return point(x / e, y / e);
	}
	
    inline bool operator == (const point &a) const 
	{
		return x == a.x && y == a.y;
	}
    
	inline int id() const
	{
		if (x >= 0 && y >= 0)
			return 2;
		else if (x <= 0 && y <= 0)
			return 0;
		else if (x > 0 && y < 0)
			return 1;
		else 
			return 3;
	}
	
	inline bool operator < (const point &a) const 
	{
		return id() < a.id() || id() == a.id() && ((*this) * a) > 0;	
	}	
}
```

- **强哥德巴赫猜想** 任一大于2的偶数都可写成两个素数之和。
- **弱哥德巴赫猜想** 任何一个大于7的奇数都能被表示成三个奇质数的和。
- **广义孪生素数猜想** 对所有自然数 $k$，存在无穷多个素数对 $(p, p + 2k)$。

### 树形DP典例

#### 题目大意

- 给一棵 $n$ 个点的带边权树，要求找出 $k$ 个点 $A_1, A_2, \dots, A_k$，使得 $\sum\limits_{i = 1}^{k - 1}\text{dist}(A_i,A_{i + 1})$ 最小。

- $n,k \le 3000$

#### 解法

- 设 $f_{u,j}$ 表示从点 $u$ 出发，在 $u$ 的子树中经过 $j$ 个点最后回到点 $u$ 的最小距离和。

- 设 $g_{u,j}$ 表示从点 $u$ 出发，在 $u$ 的子树中经过 $j$ 个点最后停在任意一点（也相当于从 $u$ 的子树中任意一点出发，经过 $j$ 个点最后回到点$u$）的最小距离和。

- 设 $h_{u,j}$ 表示在 $u$ 的子树中从任意一点出发，经过 $j$ 个点并保证经过点 $u$，最后停在任意一点的最小距离和。

- 显然 $f,g,h$ 都是由 $u$ 的子节点 $v$ 转移过来，则我们可以得到如下转移（为了描述方便，设已经处理完的 $u$ 的子节点的子树结点集合为 $A$，当前处理的子节点 $v$ 的子树结点集合为$B$，用 $\to$ 表示每种转移所对应在树上走的方案，转移前令 $f' = f, g' = g, h' = h$）：

  - 对于 $f_{u,j}$
    $$
    \begin{aligned}
    f'_{u,j+k} &= \min\{f_{v,k} + f_{u,j} + 2\text{dist}(u,v)\} &  u \to A \to u \to B \to u \\
    \end{aligned}
    $$

  - 对于 $g_{u,j}$
    $$
    \begin{aligned}
    g'_{u, j + k} &= \min\{g_{v, k} + f_{u,j} + \text{dist}(u,v)\} & u \to A \to u \to B \\
    g'_{u, j + k} &= \min\{f_{v, k} + g_{u,j} + 2\text{dist}(u,v)\} & u \to B \to u \to A \\
    \end{aligned}
    $$

  - 对于 $h_{u,j}$
    $$
    \begin{aligned}
    h'_{u, j + k} & = \min\{f_{v,k} + h_{u,j} + 2\text{dist}(u,v)\} & A \to u \to B \to u \to A \\
    h'_{u, j + k} &= \min\{h_{v,k} + f_{u,j} + 2\text{dist}(u,v)\} & B \to u \to A \to u \to B \\
    h'_{u, j + k} & = \min\{g_{v, k} + g_{u,j} + \text{dist}(u,v)\} & A \to u \to B
    \end{aligned}
    $$

- 时间复杂度 $\mathcal O(n^2)$。

## Mistakes

- 树状数组是**多叉树**，KMP 以 0为根。
- 动态开点的线段树做区间加等操作时要动态记录区间内的节点个数
- 计算几何能不用实数就不用实数。
- 不要随意地使用一些常数优化，如位运算等，使用之前要想清楚是否有问题。
- 正常出题人不会卡常数，除非你的做法不是标算或者你写错了。
- 负数别用位运算，写的时候想一想。
- 权值线段树上的负数域用 (l+r)/2 也会错（如 -1 0），要先转成正数运算后再转回去。
- **单调队列别抽风了从队尾取答案。**
- `vector` 常常会有些奇怪的空间问题，所需空间较大时能不用就不用。
- 仔细算清楚动态开点线段树的空间。
- 注意如果某个变量在使用其原值的过程中被更新的情况**（如树的动态直径）**，因在外层备份。
- 注意要避免建图时建重复的边（/2)，部分题目两倍常数可能就过不了了。
- $0^0 = 1$，别算错了。
- 能离散就别写 std::map。